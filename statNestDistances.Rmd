---
title: "mean_dist_nest_model"
output:
  html_document: default
  pdf_document: default
date: "2024-05-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The aim of this script is to statistically test the link between average daily distance from the nest and various factors as explanatory variables (drought index, sex, age of chicks, etc.) via the construction of a mixed model.

## Load packages

```{r, message= FALSE, warning=FALSE}
library(dplyr)
library(corrplot)
library(lme4) # for lmer
library(nlme) #for gls (glmm)
library(lmerTest)
library(Matrix) 
library(MuMIn) # for Dredge()
library(car) # for vif()
library(lubridate)
library(GGally) #correlation synthese
library(mgcv) #for gam
library(lmtest) #Breusch-Pagan test
library(effects)
library(flexmix) #for BIC extraction
library(performance) #R²
library(gridExtra)#grid.arrange
```

## Prepare DATA

```{r, warning=FALSE, message=FALSE}
data1 <-
  read.table(
    "D:/Home/ocbegassat/Documents/Oceane_BEGASSAT/Stage_2024_ECOBIO/Scripts_current/Analyses_stats/matrice_ciccic_2025.txt",
    header = T,
    dec = ","
  )
#79 periods

data <-
  data1[, c(
    "device",
    "id_30",
    "Deviceyear",
    "POP",
    "SEXE",
    "PRODUCTION_envol",
    "CHICKAGE",
    "SPEI_har_pond",
    "Mean_nest_dist"
  )]

#Convert into the good type
data <- data %>%
  mutate(across(c(POP, SEXE, PRODUCTION_envol, CHICKAGE), as.factor)) %>%
  mutate(across(c(SPEI_har_pond, Mean_nest_dist), as.numeric))


# With the default settings, the scale() function calculates the vector’s mean and standard deviation, here it is not needed as we have only one numeric explictaive variable
# then “scales” each element by removing the mean and dividing by the sd.
#Here it is necessary sinc the meteorological descriptors have different units

table(data$PRODUCTION_envol)
# Only one individual has 5 chicks :add it to the 4+ class
data$PRODUCTION_envol <-
  ifelse(
    data$PRODUCTION_envol == 4 |
      data$PRODUCTION_envol == 5,
    "4+",
    as.character(data$PRODUCTION_envol)
  )

data$PRODUCTION_envol <- as.factor(data$PRODUCTION_envol)
data$device <- as.factor(data$device)
```

## Explicative variables description and distribution

```{r}

#SPEI Hargreaves
dotchart(data$SPEI_har_pond,pch=16,col='blue',xlab='SPEI')
# Histogram
hist(data$SPEI_har_pond,col='blue',xlab="SPEI",main="") #not normal

# Quantile-Quantile plot
qqnorm(data$SPEI_har_pond,pch=16,col='blue',xlab='')
qqline(data$SPEI_har_pond,col='red') #not normal

#factors
#Chick production 
table(data$PRODUCTION_envol) #pas équilibré

#SEXE
table(data$SEX)

#Chick age
table(data$CHICKAGE)
```

#Y distribution

```{r}
test <-
  data[, c(
    "device",
    "id_30",
    "Mean_nest_dist",
    "POP",
    "SEXE",
    "PRODUCTION_envol",
    "CHICKAGE",
    "SPEI_har_pond"
  )]
test$PRODUCTION_envol <- as.factor(test$PRODUCTION_envol)
test$device <- as.factor(test$device)

#Check for missing values
colSums(is.na(test))

#Y distribution

par(mfrow = c(2, 2))
# Boxplot
boxplot(test$Mean_nest_dist, col = 'blue', ylab = 'Mean daily distances to the nest')
# Cleveland plot
dotchart(
  test$Mean_nest_dist,
  pch = 16,
  col = 'blue',
  xlab = 'Mean daily distances to the nest'
)
# Histogram
hist(
  test$Mean_nest_dist,
  col = 'blue',
  xlab = "Mean daily distances to the nest",
  main = ""
)
# Quantile-Quantile plot
qqnorm(
  test$Mean_nest_dist,
  pch = 16,
  col = 'blue',
  xlab = ''
)
qqline(test$Mean_nest_dist, col = 'red')
# Non normal
shapiro.test(test$Mean_nest_dist) #W = 0.80189, p-value = 6.279e-09 not normal
#No outlier
```

No outliers, non-linear distribution

### Potential relationships between Xs and Y

```{r}
par(mfrow=c(1,4))

# SPEI
plot(
  test$Mean_nest_dist ~ test$SPEI_har_pond,
  pch = 16,
  col = 'blue',
  xlab = 'SPEI',
  ylab = 'Mean distance to the nest'
)

# Production
boxplot(Mean_nest_dist ~ PRODUCTION_envol,
        data = test,
        main = "Mean distance to the nest")
# sex
boxplot(
  Mean_nest_dist ~ SEXE,
  data = test,
  col = c('blue3', 'red2'),
  main = "Mean distance to the nest"
)
# Chick age
boxplot(
  Mean_nest_dist ~ CHICKAGE,
  data = test,
  col = c('blue3', 'red2'),
  main = "Mean distance to the nest"
)
```

Mean distance to the nest: decreases with the number of chicks, increases in males, slightly increases with the chick age (not tested yet)

### Log transformation to avoid heteroskedasticity:

```{r}
test$Mean_nest_dist_log <- log(test$Mean_nest_dist)

#new distribution
par(mfrow = c(2, 2))
# Boxplot
boxplot(test$Mean_nest_dist_log,
        col = 'blue',
        ylab = 'Mean of the monthly mean (log) of daily distances to the nest')
# Cleveland plot
dotchart(
  test$Mean_nest_dist_log,
  pch = 16,
  col = 'blue',
  xlab = 'Mean of the monthly mean (log) of daily distances to the nest'
)
# Histogram
hist(
  test$Mean_nest_dist_log,
  col = 'blue',
  xlab = "Mean of the monthly mean (log) of daily distances to the nest",
  main = ""
)
# Quantile-Quantile plot
qqnorm(
  test$Mean_nest_dist_log,
  pch = 16,
  col = 'blue',
  xlab = ''
)
qqline(test$Mean_nest_dist_log, col = 'red')

shapiro.test(test$Mean_nest_dist)# W = 0.80189, p-value = 6.279e-09 Non normal
shapiro.test(test$Mean_nest_dist_log) #W = 0.98495, p-value = 0.4809 Normal
#No outlier
```

### LOG Choice of the random factors

Same process as before

```{r}

#LM, constant model
mod <- lm(Mean_nest_dist_log~1, data = test)
AICc(mod)

#LMM, full model
mod1 <- lmer(
  Mean_nest_dist_log ~ SPEI_har_pond * CHICKAGE + SPEI_har_pond * PRODUCTION_envol + SPEI_har_pond *
    SEXE + (1 | POP / device),
  data = test
)
AICc(mod1)


mod11 <- lmer(
  Mean_nest_dist_log ~ SPEI_har_pond * CHICKAGE + SPEI_har_pond * PRODUCTION_envol + SPEI_har_pond *
    SEXE + (1 | POP),
  data = test
)
AICc(mod11) 

mod12 <- lmer(
  Mean_nest_dist_log ~ SPEI_har_pond * CHICKAGE + SPEI_har_pond * PRODUCTION_envol + SPEI_har_pond *
    SEXE + (1 | device),
  data = test
)
AICc(mod12) 


mod2 <- lm(
  Mean_nest_dist_log ~ SPEI_har_pond * CHICKAGE + SPEI_har_pond * PRODUCTION_envol + SPEI_har_pond *
    SEXE,
  data = test
)
AICc(mod2)

```

It keeps the same random structure

### LOG GAMM with the complete log model: linearity of the relationship?

```{r}
#log transformation seems to be useful: complete model
modgam1 <-
  gamm(
    Mean_nest_dist_log ~ s(SPEI_har_pond) + SEXE + PRODUCTION_envol
      CHICKAGE,
    random = list(device = ~ 1),
    method = "ML",
    data = test
  )
AICc(modgam1) #193.8934

#Try to remove SEX
modgam2 <- gamm(
  Mean_nest_dist_log ~  s(SPEI_har_pond) + PRODUCTION_envol + 
    CHICKAGE,
  random = list(device = ~ 1),
  method = "ML",
  data = test
)
AICc(modgam2)#192.8182 delta AICC < 2 so remove it

#Try to remove Chickage
modgam3 <-
  gamm(
    Mean_nest_dist_log ~ s(SPEI_har_pond)+ PRODUCTION_envol + SEXE,
    random = list(device = ~ 1),
    method = "ML",
    data = test
  )
AICc(modgam3)# 192.1515 idem

#without the factors
modgam <-
  gamm(
    Mean_nest_dist_log ~ s(SPEI_har_pond),
    random = list(device = ~ 1),
    method = "ML",
    data = test
  )
AICc(modgam) #191.1692

plot(modgam$gam)
summary(modgam$gam) #edf = 1 -> linear relationship

# Each plot represents the smoothed effect of a continuous variable on the response variable.
# The solid line is the estimated effect, and the shaded areas represent the 95% confidence intervals.
summary(modgam$lme)
```

Linear relationship for SPEI --\> LMM

## LOG model sleection
```{r}

table(test$CHICKAGE, test$PRODUCTION_envol)
table(test$CHICKAGE, test$SEXE)
table(test$SEXE, test$PRODUCTION_envol)


#Selection with Dredge
fullmod <- lmer(
  Mean_nest_dist_log ~ SPEI_har_pond * CHICKAGE + SPEI_har_pond * PRODUCTION_envol + SPEI_har_pond *
    SEXE + (1 | device), data = test, REML = F, na.action = na.fail)
Dredge <- dredge(fullmod)

mods <- get.models(Dredge, subset = 1:10) 
r2_list <- lapply(mods, r.squaredGLMM)
r2_df <- do.call(rbind, r2_list)
r2_df <- cbind(Model = names(mods), r2_df)

modglm <- lmer(Mean_nest_dist_log~   SPEI_har_pond + PRODUCTION_envol +
                  (1|device), data = test, REML = T, na.action = na.fail)
confint(modglm, oldNames=FALSE) #CHICKAGE ESTIMATE NULL
summary(modglm)
r.squaredGLMM(modglm)

modglm2 <- lmer(Mean_nest_dist_log~   SPEI_har_pond + PRODUCTION_envol + CHICKAGE +
                  (1|device) , data = test, REML = T, na.action = na.fail)
confint(modglm2, oldNames=FALSE) #CHICKAGE ESTIMATE NULL
summary(modglm2)
r.squaredGLMM(modglm2)

modglm3 <- lmer(Mean_nest_dist_log~  SPEI_har_pond + PRODUCTION_envol + SEXE +
                  (1|device), data = test, REML = T, na.action = na.fail)
confint(modglm3, oldNames=FALSE) 
summary(modglm3)
r.squaredGLMM(modglm3)
```


## LOG Model validation: assumption checking

```{r}
#selected model
#REML = T for model validation (provides less biased estimates of the variance components)
modok <- lmer(Mean_nest_dist_log~ SPEI_har_pond + PRODUCTION_envol +
                  (1|device), data = test, REML = T, na.action = na.fail)
AICc(modok)#183.0606

# 1. Moyennes marginales par niveau de PRODUCTION_envol
emm <- emmeans(modok, ~ PRODUCTION_envol)

# 2. Comparaisons par paires avec correction de Tukey
contrasts_prod <- pairs(emm, adjust = "tukey")

# 3. Résumé avec IC95% et tests de signification
summary(contrasts_prod, infer = c(TRUE, TRUE))



#residuals (normality and independance)
qqnorm(resid(modok))

qqline(resid(modok)) #ok for residuals normality
#idem
hist(residuals(modok))

# residuals vs fitted (homoscedasticity)
plot(residuals(modok)~fitted(modok)
      , col='blue'
      , pch=16)
abline(h = 0)
#ok for independance: no pattern


#residuals against factors (relationship linearity and variance equality)
plot(residuals(modok)~ test$SPEI_har_pond,
         ylab = "Residuals",
         xlab = "SPEI",
         main = "")
abline(h = 0)

#marginal and conditional R-squared values 
r.squaredGLMM(modok)
#             R2m       R2c
# [1,] 0.02894783 0.6969309

#IConfidence interval (95%) for each variable
confint(modok, oldNames=FALSE)

#Homoscedasticity Breusch-Pagan test
# Model residuals
residus <- resid(modok)
# bptest(resid)

#Regression residuals - variables
lm_resid <- lm(residus^2 ~ SPEI_har_pond + SEXE + CHICKAGE, data = test)

# Effectuer le test Breusch-Pagan
bptest(lm_resid)
#ok ! p>0.005

summary(modok)

#PLot it
plot(residuals(modok)~ test$SPEI_har_pond,
         ylab = "Residuals",
         xlab = "SPEI",
         main = "")
abline(h = 0)

plot(modok)
```

Conclusion: - The daily mean distance to the nest decreases in wetter conditions (high SPEI) So it increases in dryer conditions

# Representation with and without the log trasnformation

```{r}
m
#Remove random variable
modok1 <- lm(Mean_nest_dist_log~ SPEI_har_pond + PRODUCTION_envol, data = test, REML = T, na.action = na.fail)

# Plot predicted values of the model with respect to the factor PRODUCTION_envol
#plot_model(modok, type = "pred", terms = "PRODUCTION_envol")

# Create a new data frame for prediction that covers the range of SPEI_har_pond 
# and includes all levels of the categorical variable PRODUCTION_envol
newdat <- expand.grid(
  SPEI_har_pond = seq(-1.469, 1.76, 0.1),        # Sequence of SPEI_har_pond values spanning observed range
  PRODUCTION_envol = levels(test$PRODUCTION_envol)  # All factor levels of PRODUCTION_envol
)

library(stats)

# Generate predictions from the linear model for newdat
newdat$pred <- stats::predict(modok1, newdat)

# Extract residuals from the fitted model
resid <- residuals(modok)

# Calculate the standard deviation of residuals, representing model error variance
sigma_lm <- sd(resid)

# Construct the model matrix for newdat based on the model formula (excluding response)
Designmat <- model.matrix(formula(modok1)[-2], newdat)

# Calculate the variance of predictions based on the model covariance matrix
predvar <- diag(Designmat %*% vcov(modok1) %*% t(Designmat))

# Calculate standard error of the predictions
newdat$SE <- sqrt(predvar)

# Calculate combined standard error incorporating residual variance (prediction uncertainty + residual variance)
newdat$SE2 <- sqrt(predvar + sigma_lm^2)

# Initialize the base ggplot with predicted values, grouped by PRODUCTION_envol factor levels
g0 <- ggplot(newdat, aes(x = SPEI_har_pond, y = pred, color = PRODUCTION_envol)) + 
  geom_line()

# Define multiplier for 95% confidence intervals (approximate)
cmult <- 1.96  

# Plot predicted values with confidence ribbons showing uncertainty bounds
graph1 <- g0 + 
  geom_ribbon(aes(ymin = pred - cmult * SE, ymax = pred + cmult * SE, fill = PRODUCTION_envol), 
              alpha = 0.1, linetype = 0) + 
  # Add original observed data points, colored by PRODUCTION_envol
  geom_point(data = test, aes(x = SPEI_har_pond, y = Mean_nest_dist_log, color = PRODUCTION_envol)) +
  theme_classic() +
  labs(x = "SPEI", y = "Log(Distance from the nest)", color = "PRODUCTION_envol", fill = "PRODUCTION_envol") +
  theme(axis.text.x = element_text(size = 16),
        axis.text.y = element_text(size = 16),
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18))

graph1


#dégradé selon production
my_colors <- scales::seq_gradient_pal("blue", "red")(seq(0, 1, length.out = 4))

graph1 <- g0 + 
  geom_ribbon(aes(ymin = pred - cmult * SE, ymax = pred + cmult * SE, fill = PRODUCTION_envol), 
              alpha = 0.1, linetype = 0) + 
  geom_point(data = test, aes(x = SPEI_har_pond, y = Mean_nest_dist_log, color = PRODUCTION_envol)) +
  scale_color_manual(values = my_colors) +
  scale_fill_manual(values = my_colors) +
  theme_classic() +
  labs(x = "SPEI", y = "Log(Distance from the nest)", color = "PRODUCTION_envol", fill = "PRODUCTION_envol") +
  theme(axis.text.x = element_text(size = 16),
        axis.text.y = element_text(size = 16),
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18))

graph1 <- ggplot(newdat, aes(x = SPEI_har_pond, y = pred)) + 
  geom_line(color = "black") +
  geom_ribbon(aes(ymin = pred - cmult * SE, ymax = pred + cmult * SE), 
              alpha = 0.2, fill = "steelblue") +
  geom_point(data = test, aes(x = SPEI_har_pond, y = Mean_nest_dist_log), 
             alpha = 0.6, size = 1) +
  facet_wrap(~ PRODUCTION_envol) +
  theme_classic() +
  labs(x = "SPEI", y = "Log(Distance from the nest)") +
  theme(strip.text = element_text(size = 16),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16))



############ OU bien

library(ggeffects)

# Prédictions du modèle
eff_spei <- ggpredict(modok1, terms = "SPEI_har_pond")

# Graphique avec points individuels, production fixée à 1
ggplot() +
 # Points bruts
  geom_point(
  data = subset(test, PRODUCTION_envol == 1),
  aes(x = SPEI_har_pond, y = Mean_nest_dist_log),
  alpha = 0.4, color = "black", shape = 16
)+
  geom_line(data = eff_spei, aes(x = x, y = predicted), color = "black", size = 1) +  # Courbe prédite
  geom_ribbon(data = eff_spei, aes(x = x, ymin = conf.low, ymax = conf.high), 
              fill = "deepskyblue", alpha = 0.2) +  # IC95% crés par ggpredict
  labs(
    title = "Dist~SPEI",
    x = "SPEI",
    y = "Distance log() (m)"
  ) +
  theme_classic()

#le même mais dézoomé pour couvrir l'amplitude réelle de distance avec tous les nv de production
ggplot() +
  geom_point(
  data = subset(test, PRODUCTION_envol == 1),
  aes(x = SPEI_har_pond, y = Mean_nest_dist_log),
  alpha = 0.4, color = "black", shape = 16
)+
  geom_line(data = eff_spei, aes(x = x, y = predicted), color = "black", size = 1) +
  geom_ribbon(data = eff_spei, aes(x = x, ymin = conf.low, ymax = conf.high), 
              fill = "deepskyblue", alpha = 0.2) +
  labs(
    title = "Dist~SPEI",
    x = "SPEI",
    y = "Distance log(m)"
  ) +
  theme_classic() +
  coord_cartesian(
    ylim = range(test$Mean_nest_dist_log, na.rm = TRUE)  # force l’amplitude des données brutes
  )

#idem mais avec un effet moyen pondéré pour chaque niveau de production pour centrer la courbe et garder tous le spoints bruts

# effet marginal de SPEI_har_pond en moyennant sur PRODUCTION_envol
eff_spei <- ggemmeans(modok1, terms = "SPEI_har_pond") #calcule les moyennes marginales : ça prend les prédictions pour chaque niveau de PRODUCTION_envol puis les moyenne (pondéré selon les fréquences dans les données).

# Visualisation
ggplot() +
  geom_point(data = test, aes(x = SPEI_har_pond, y = Mean_nest_dist_log), 
             alpha = 0.4, color = "black", shape = 16) +
  geom_line(data = eff_spei, aes(x = x, y = predicted), 
            color = "black", size = 1) +
  geom_ribbon(data = eff_spei, aes(x = x, ymin = conf.low, ymax = conf.high), 
              fill = "deepskyblue", alpha = 0.2) +
  labs(
    title = "Distance ~ SPEI (effet marginal sur PRODUCTION)",
    x = "SPEI",
    y = "Distance log(m)"
  ) +
  theme_classic()


# Effet marginal de PRODUCTION_envol
#Comparer la distance de prospection moyenne selon la taille de la nichée. Cela permet de voir s'il y a une différence significative entre produire 1 jeune ou 4+, par exemple.
eff_prod <- ggpredict(modok, terms = "PRODUCTION_envol")
ggplot() +
  geom_jitter(data = test, aes(x = as.factor(PRODUCTION_envol), y = Mean_nest_dist_log),
              width = 0.2, alpha = 0.5, color = "grey34", shape = 16) +  # Points observés
  geom_pointrange(data = eff_prod, 
                  aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high),
                  color = "black", size = 1) +
  labs(
    title = "Dist~Production",
    x = "Nb fledglings",
    y = "Distance log() (m)"
  ) +
  theme_classic()


# Prédictions du modèle
eff_modok <- ggpredict(modok1, terms = c("SPEI_har_pond", "PRODUCTION_envol"))
eff_modok$PRODUCTION_envol <- eff_modok$group

# Graphique avec points individuels
ggplot() +
  geom_point(data = test, aes(x = SPEI_har_pond, y = Mean_nest_dist_log), 
             alpha = 0.5, color = "black", shape = 16, size = 0.8) +  # Points bruts
  geom_line(data = eff_modok, aes(x = x, y = predicted), color = "black", size = 0.6) +  # Courbe prédite
  geom_ribbon(data = eff_modok, aes(x = x, ymin = conf.low, ymax = conf.high), 
              fill = "deepskyblue", alpha = 0.2) +  # IC95% crés par ggpredict
  labs(
    title = "HR~SPEI",
    x = "SPEI",
    y = "Mean_nest_dist_log"
  ) +
  facet_wrap(vars(PRODUCTION_envol))+
  theme_classic()

```

Test du modèle en enlevant le smois de - de 21j

```{r}
id_30_to_delete <- c("190657_2021_2", "190665_2020_1", "200015_2020_1")
test1 <-  test[!(test$id_30 %in% id_30_to_delete), ]


#selected model
#REML = T for model validation (provides less biased estimates of the variance components)
modok <- lmer(Mean_nest_dist_log~ SPEI_har_pond +
                  (1|POP/device) + (1|PRODUCTION_envol), data = test1, REML = T, na.action = na.fail)
AICc(modok)#178.942

#residuals (normality and independance)
qqnorm(resid(modok))

qqline(resid(modok)) #ok for residuals normality
#idem
hist(residuals(modok))

# residuals vs fitted (homoscedasticity)
plot(residuals(modok)~fitted(modok)
      , col='blue'
      , pch=16)
abline(h = 0)
#ok for independance: no pattern


#residuals against factors (relationship linearity and variance equality)
plot(residuals(modok)~ test1$SPEI_har_pond,
         ylab = "Residuals",
         xlab = "SPEI",
         main = "")
abline(h = 0)

#marginal and conditional R-squared values 
r.squaredGLMM(modok)
#             R2m       R2c
# [1,] 0.02894783 0.6969309 ---> 0.03287128 0.6738673

#IConfidence interval (95%) for each variable
confint(modok, oldNames=FALSE)

#Homoscedasticity Breusch-Pagan test
# Model residuals
residus <- resid(modok)
# bptest(resid)

#Regression residuals - variables
lm_resid <- lm(residus^2 ~ SPEI_har_pond + SEXE + CHICKAGE, data = test1)

# Effectuer le test Breusch-Pagan
bptest(lm_resid)
#ok ! p>0.005

summary(modok)

#PLot it
plot(residuals(modok)~ test$SPEI_har_pond,
         ylab = "Residuals",
         xlab = "SPEI",
         main = "")
abline(h = 0)

```


Correlation matrix between the 4 descriptors
```{r}

data1 <-
  read.table(
    "D:/Home/ocbegassat/Documents/Oceane_BEGASSAT/Stage_2024_ECOBIO/Scripts_current/Analyses_stats/matrice_ciccic_2025_odba.txt",
    header = T,
    dec = ","
  )
#79 periods

summary(data1)
hist(data1$HRker95_foraging)
hist(data1$Mean_nest_dist)
hist(data1$ratio_foraging_all)
hist(data1$daily_mean_ODBA)

shapiro.test(data1$HRker95_foraging)
shapiro.test(data1$Mean_nest_dist)
shapiro.test(data1$ratio_foraging_all)
shapiro.test(data1$daily_mean_ODBA)

cor(data1[, c("HRker95_foraging", "Mean_nest_dist", "ratio_foraging_all", "daily_mean_ODBA")], method = "spearman")

library(corrplot)
# Calcul de la matrice de corrélation avec Spearman
corr_matrix <- cor(data1[, c("HRker95_foraging", "Mean_nest_dist", "ratio_foraging_all", "daily_mean_ODBA")], 
                   method = "spearman")

# Ordre personnalisé (remplacez par l'ordre souhaité)
custom_order <- c("HRker95_foraging", "Mean_nest_dist", "ratio_foraging_all", "daily_mean_ODBA")

# Réorganisation de la matrice selon cet ordre
corr_matrix <- corr_matrix[custom_order, custom_order]

corrplot(corr_matrix, method = "color", type = "upper", addCoef.col = "black", tl.col = "black", tl.srt = 45)

#to have the p values
cor_test1 <- cor.test(data1$HRker95_foraging, data1$Mean_nest_dist, method = "spearman")
print(cor_test1$p.value)

# Exemple de corrélation pour HRker95_foraging et ratio_foraging_all
cor_test2 <- cor.test(data1$HRker95_foraging, data1$ratio_foraging_all, method = "spearman")
print(cor_test2$p.value)

# Exemple de corrélation pour HRker95_foraging et daily_mean_ODBA
cor_test3 <- cor.test(data1$HRker95_foraging, data1$daily_mean_ODBA, method = "spearman")
print(cor_test3$p.value)

# Exemple de corrélation pour Mean_nest_dist et ratio_foraging_all
cor_test4 <- cor.test(data1$Mean_nest_dist, data1$ratio_foraging_all, method = "spearman")
print(cor_test4$p.value)

# Exemple de corrélation pour Mean_nest_dist et daily_mean_ODBA
cor_test5 <- cor.test(data1$Mean_nest_dist, data1$daily_mean_ODBA, method = "spearman")
print(cor_test5$p.value)

# Exemple de corrélation pour ratio_foraging_all et daily_mean_ODBA
cor_test6 <- cor.test(data1$ratio_foraging_all, data1$daily_mean_ODBA, method = "spearman")
print(cor_test6$p.value)
```

